#+STARTUP: showall
#+OPTIONS: toc:2
#+INFOJS_OPT: view:info toc:tdepth:2

**** Author: Rob Alicea
**** Date: <2024-06-23>
**** Description: This document describes how to set up and use the Internet Monitoring Suite to continuously monitor your internet connection and log results for better communication with your ISP.

* Internet Monitoring Setup

This document describes how to set up an internet monitoring script that runs periodically using cron and Docker with Podman. The script ensures that only one instance runs at a time and organizes data into a structured file system.

** Table of Contents
- [[#introduction][Introduction]]
- [[#requirements][Requirements]]
- [[#bash-script][Bash Script]]
- [[#setting-up-the-cron-job][Setting Up the Cron Job]]
- [[#handling-pc-downtime][Handling PC Downtime with Anacron]]
- [[#docker-setup][Docker Setup]]
- [[#advantages-of-podman][Advantages of Using Podman Rootless Containers vs. Docker]]

* Introduction

The purpose of this setup is to monitor your internet connection, log the results, and generate a master log in PDF format. The script runs periodically and ensures that only one instance runs at a time, storing data in a structured file system.

* Requirements

- Fedora 40 or compatible Linux distribution
- `speedtest-cli`
- `pandoc`
- `cron`
- `anacron` (optional for handling downtime)
- `podman` for containerization

* Bash Script

The following bash script performs the internet monitoring tasks. It logs the results and generates a master log in PDF format. It also ensures that only one instance runs at a time and organizes data into a structured file system.

#+BEGIN_SRC sh :tangle /home/rob/Dotfiles/monitoring-suite/internet_monitoring.sh
#!/bin/bash

# Toggle logging
LOGGING=true

if [ "$LOGGING" = true ]; then
    exec > >(tee -a /tmp/internet_monitoring.log) 2>&1
fi

echo "Script started at: $(date)"
echo "Current user: $(whoami)"

# Define a log directory with session timestamp
SESSION_TIMESTAMP=$(date +'%Y-%m-%d_%H-%M-%S')
LOG_DIR="$HOME/internet_monitoring_logs/$SESSION_TIMESTAMP"
mkdir -p "$LOG_DIR"

# Define a lock file to ensure only one instance runs at a time
LOCKFILE="/tmp/internet_monitoring.lock"

# Check if another instance is running and exit if true
if [ -f "$LOCKFILE" ] && kill -0 "$(cat "$LOCKFILE")"; then
    echo "Another instance is already running. Exiting."
    exit 1
fi

# Write the current PID to the lock file
echo $$ > "$LOCKFILE"

# Trap to ensure the lock file is removed on script exit
trap "rm -f $LOCKFILE" EXIT

# Function to perform an internet speed test
run_internet_speed_test() {
    echo "Running internet speed test..."
    if command -v speedtest-cli > /dev/null; then
        speedtest-cli --simple >> "$LOG_DIR/internet_speed_log.txt" 2>&1
        if [ $? -ne 0 ]; then
            echo "Error: speedtest-cli failed" >> "$LOG_DIR/error_log.txt"
        else
            echo "Internet speed test completed and logged."
        fi
    else
        echo "Error: speedtest-cli is not installed" >> "$LOG_DIR/error_log.txt"
    fi
}

# Function to perform a latency check
run_latency_check() {
    echo "Running latency check..."
    ping -c 10 8.8.8.8 >> "$LOG_DIR/internet_latency_log.txt" 2>&1
    if [ $? -ne 0 ]; then
        echo "Error: ping failed" >> "$LOG_DIR/error_log.txt"
    else
        echo "Latency check completed and logged."
    fi
}

# Function to perform jitter measurement
run_jitter_measurement() {
    echo "Running jitter measurement..."
    ping -c 100 8.8.8.8 | awk -F'=' '/time=/ {print $NF}' | sed 's/ ms//' > "$LOG_DIR/jitter_log.txt"
    awk '{delta=$1-last; last=$1; if (NR>1) {print (delta<0 ? -delta : delta); sum+=delta}} END {print "Average jitter:", sum/NR, "ms"}' "$LOG_DIR/jitter_log.txt" >> "$LOG_DIR/internet_latency_log.txt"
}

# Function to measure packet loss
measure_packet_loss() {
    echo "Measuring packet loss..."
    ping -c 100 8.8.8.8 | grep 'packet loss' >> "$LOG_DIR/internet_latency_log.txt"
}

# Function to run traceroute
run_traceroute() {
    echo "Running traceroute..."
    traceroute 8.8.8.8 > "$LOG_DIR/traceroute_log.txt"
}

# Function to measure DNS resolution time
measure_dns_resolution_time() {
    echo "Measuring DNS resolution time..."
    dig google.com | grep 'Query time' >> "$LOG_DIR/dns_resolution_log.txt"
}

# Function to measure latency to multiple endpoints
measure_multi_endpoint_latency() {
    echo "Measuring latency to multiple endpoints..."
    for host in google.com cloudflare.com facebook.com; do
        echo "Pinging $host" >> "$LOG_DIR/multi_endpoint_latency_log.txt"
        ping -c 10 $host | grep 'time=' >> "$LOG_DIR/multi_endpoint_latency_log.txt"
    done
}

# Function to create a master log
create_master_log() {
    echo "Creating master log..."
    {
        echo "Internet Monitoring Log - $SESSION_TIMESTAMP"
        echo "----------------------------------"
        echo "Internet Speed Test Log"
        cat "$LOG_DIR/internet_speed_log.txt"
        echo "----------------------------------"
        echo "Latency Test Log"
        cat "$LOG_DIR/internet_latency_log.txt"
        echo "----------------------------------"
        echo "Jitter Measurement"
        cat "$LOG_DIR/jitter_log.txt"
        echo "----------------------------------"
        echo "Packet Loss Measurement"
        cat "$LOG_DIR/internet_latency_log.txt" | grep 'packet loss'
        echo "----------------------------------"
        echo "Traceroute Log"
        cat "$LOG_DIR/traceroute_log.txt"
        echo "----------------------------------"
        echo "DNS Resolution Time"
        cat "$LOG_DIR/dns_resolution_log.txt"
        echo "----------------------------------"
        echo "Multi-Endpoint Latency"
        cat "$LOG_DIR/multi_endpoint_latency_log.txt"
        echo "----------------------------------"
        if [ -f "$LOG_DIR/error_log.txt" ]; then
            echo "Errors:"
            cat "$LOG_DIR/error_log.txt"
        fi
    } > "$LOG_DIR/master_log.txt"
    echo "Master log created at $LOG_DIR/master_log.txt"
}

# Function to convert master log to PDF
convert_master_log_to_pdf() {
    echo "Converting master log to PDF..."
    if command -v pandoc > /dev/null; then
        pandoc "$LOG_DIR/master_log.txt" -o "$LOG_DIR/master_log.pdf"
        if [ $? -ne 0 ]; then
            echo "Error: pandoc failed to create PDF" >> "$LOG_DIR/error_log.txt"
        else
            echo "PDF created at $LOG_DIR/master_log.pdf"
        fi
    else
        echo "Pandoc is not installed. Skipping PDF conversion."
    fi
}

# Run the monitoring tasks
run_internet_speed_test
run_latency_check
run_jitter_measurement
measure_packet_loss
run_traceroute
measure_dns_resolution_time
measure_multi_endpoint_latency
create_master_log
convert_master_log_to_pdf

echo "Script completed at: $(date)"
#+END_SRC

* Setting Up the Cron Job

To set up a cron job that runs the script every 4 hours, follow these steps:

1. Open the cron table for the user `rob`:
   #+BEGIN_SRC sh
   crontab -e
   #+END_SRC

2. Add the following line to schedule the script to run every 4 hours:
   #+BEGIN_SRC crontab
   0 */4 * * * /home/rob/Dotfiles/monitoring-suite/internet_monitoring.sh >> /home/rob/Dotfiles/monitoring-suite/cron.log 2>&1
   #+END_SRC

* Handling PC Downtime with Anacron

If the PC is turned off or asleep when the cron job is scheduled to run, the job will not execute. To handle this, you can use `anacron`, which ensures that jobs are run when the PC is turned back on.

1. Install `anacron`:
   #+BEGIN_SRC sh
   sudo dnf install anacron
   #+END_SRC

2. Edit the `/etc/anacrontab` file to include your script. Add the following line:
   #+BEGIN_SRC sh
   @daily   5   internet_monitoring   /home/rob/Dotfiles/monitoring-suite/internet_monitoring.sh
   #+END_SRC

3. Start the `anacron` service:
   #+BEGIN_SRC sh
   sudo systemctl enable anacron
   sudo systemctl start anacron
   #+END_SRC

This setup will ensure that your internet monitoring script runs periodically and logs the necessary data, even if the PC is turned off during the scheduled time.

* Docker Setup

To set up the internet monitoring script using Docker with Podman, follow these steps:

1. Create a `Dockerfile` in the same directory as your script (`/home/rob/Dotfiles/monitoring-suite/`).

#+BEGIN_SRC Dockerfile
# Use a base image with Fedora
FROM fedora:latest

# Install necessary packages
RUN dnf -y update && \
    dnf -y install speedtest-cli pandoc cronie

# Copy the script into the container
COPY internet_monitoring.sh /usr/local/bin/internet_monitoring.sh

# Make the script executable
RUN chmod +x /usr/local/bin/internet_monitoring.sh

# Set up a cron job
RUN echo "0 */4 * * * /usr/local/bin/internet_monitoring.sh >> /var/log/internet_monitoring.log 2>&1" > /etc/cron.d/internet_monitoring && \
    crontab /etc/cron.d/internet_monitoring

# Set the entrypoint to cron
ENTRYPOINT ["crond", "-n"]
#+END_SRC

2. Build the Docker image with Podman:

   Navigate to the directory containing your `Dockerfile` and run the following command to build your Docker image:

   #+BEGIN_SRC sh
   cd /home/rob/Dotfiles/monitoring-suite
   podman build -t internet-monitoring-suite .
   #+END_SRC

3. Run the Docker container with Podman:

   After building the image, you can run the container using the following command:

   #+BEGIN_SRC sh
   podman run -d --name internet-monitoring-suite internet-monitoring-suite
   #+END_SRC

* Advantages of Using Podman Rootless Containers vs. Docker

Podman is a container management tool similar to Docker but with some key differences, particularly in how it handles security and rootless containers.

1. **Rootless Operation**: Podman allows you to run containers without requiring root privileges. This enhances security as it reduces the risk of system compromise through container vulnerabilities.

2. **Docker Compatibility**: Podman uses the same container image format as Docker, making it easy to transition between the two tools. Most Docker commands also work with Podman.

3. **Daemon-less Architecture**: Unlike Docker, which relies on a central daemon to manage containers, Podman uses a daemon-less architecture. Each container runs as a child process of the Podman command, which improves resource usage and stability.

4. **Integration with Systemd**: Podman can generate systemd unit files for containers, allowing better integration with the system's service management. This makes it easier to manage and automate container lifecycle operations.

5. **Security**: Podman's rootless mode and integration with SELinux (on supported systems) provide enhanced security. Containers run with user namespaces and other Linux security features that help isolate them from the host system.

In summary, Podman offers a more secure and flexible container management experience, making it a suitable alternative to Docker, especially for rootless container operations.
